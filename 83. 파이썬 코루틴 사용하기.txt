#코루틴 사용하기


def add(a,b):
	c=a+b #add 함수가 끝나면 변수와 계산식은 사라짐.
	print(c)
	print('add 함수')

def calc():
	add(1,2) #add 함수가 끝나면 다시 calc함수로 돌아옴
	print('calc 함수')

calc()


3
add 함수
calc 함수 <- 가 출력이 됨.

calc가 메인루틴이면 add는 calc의 서브루틴임.


메인루틴에서 서브루틴을 호출하면 서브루틴의 코드를 실행한뒤 다시 메인루틴으로 돌아옴
서브 루틴이 끝나면 서브루틴의 내용은 모두 사라짐
서브루틴은 메인루틴에 종속된 관계임

코루틴은 방식이 조금 다른게 코루틴(coroutine)은 cooperative routine를 의미하는데
서로 협력하는 루틴이라는 뜻임

메인루틴과 서브루틴처럼 종속된관계가 아니라 서로 대등한 관계이며
특정한 시점에서 상대방의 코드를 실행함.

코루틴이 실행되는 동안에 메인루틴은 대기 상태가 되고
메인루틴이 실행되는 동안에는 코루틴이 대기 상태가 됨.


코루틴은 함수가 종료되지 않은 상태에서 메인루틴의 코드를 실행한 뒤
다시 돌아와서 코루틴의 코드를 실행함.

코루틴이 종료되지 않았으므로 코루틴의 내용도 계속 유지됨.

일반  함수를 호출하면 코드를 한번만 실행할 수 있지만 , 코루틴은 코드를 여러번 실행 할 수 있음.
참고로 함수의 코드를 실행하는 지점을 진입점(entry point)라고 하는데
코루틴은 진입점이 여러개인 함수임.
왜냐하면 언제든지 코루틴에 접근할 수 있기 때문이다.


#코루틴에 값 보내기

코루틴은 제너레이터의 특별한 형태임
제너레이터는 yield로 값을 발생시켰지만 코루틴은 yield로 값을 받아올수있음
당므과 같이 코루틴에 값을 보내면서 코드를 실행할 떄는 send 메서드를 사용함.
send 메서드가 보낸 값을 받아올려면 (yield) 형식으로 yield를 괄호로 묶어준뒤 변수에 저장함.

코루틴객체.send(값)
변수=(yield)

def number_coroutine():

	while True: #코루틴을 계속 유지하기 위해 무한루프를 사용함.
		x=(yield) #코루틴 바깥에서 값을 받아옴. yield를 괄호로 묶어야함
		print(x)

co=number_coroutine()
next(co) #코루틴 안에 yield까지 코드 실행(최초 실행)

co.send(1)
co.send(2)
co.send(3)

1
2
3이 출력이 됨.


























